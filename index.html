<!DOCTYPE html>
<html lang="en" data-lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SiCell — by Noonautics Labs</title>
  <meta name="description" content="SiCell is Noonautics Labs’ flagship project: full human cell simulations and a search engine for disease mechanisms and pharma targets." />
  <meta name="theme-color" content="#0b0c10" />
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0%25' stop-color='%231f6feb'/%3E%3Cstop offset='100%25' stop-color='%232bd4a1'/%3E%3C/linearGradient%3E%3C/defs%3E%3Ccircle cx='50' cy='50' r='44' fill='url(%23g)'/%3E%3C/svg%3E" />
  <style>
    :root{
      --bg:#0b0c10; --bg-soft:#0e1118; --card:#121521;
      --muted:#b7c4d8; --text:#e6ebf2;
      --accent:#1f6feb; --accent-2:#2bd4a1; --ring:rgba(31,111,235,.35);
      --border:rgba(255,255,255,.09);
      --container: min(1200px, 92vw);
      --radius:16px;
      --pad: clamp(18px, 2.2vw, 28px);
      --header-h: 64px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    html{scroll-behavior:smooth}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:var(--text); line-height:1.6; background:var(--bg);
      padding-top: var(--header-h);
    }
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}
    .container{width:var(--container); margin:0 auto; padding:0 8px}

    /* Header */
    header{
      position: fixed; top: 0; left: 0; right: 0; z-index: 200;
      backdrop-filter: saturate(140%) blur(6px);
      background: linear-gradient(to bottom, rgba(11,12,16,.86), rgba(11,12,16,.6) 60%, transparent);
      border-bottom: 1px solid var(--border);
      transform: translateY(0);
      transition: transform .25s ease, background .2s ease, box-shadow .2s ease;
    }
    header.scrolled{ background: rgba(11,12,16,.92); box-shadow: 0 6px 22px rgba(0,0,0,.28) }
    header.hide{ transform: translateY(-100%) }
    .nav{display:flex; align-items:center; justify-content:space-between; padding:12px 0}
    .brand{display:flex; align-items:center; gap:12px; font-weight:700}
    .logo{ width:28px; height:28px; border-radius:8px;
      background: conic-gradient(from 210deg, var(--accent), var(--accent-2) 40%, #6ee7ff 70%, var(--accent));
      box-shadow: 0 0 0 4px rgba(255,255,255,.03), 0 8px 30px var(--ring); }
    .brand small{display:block; font-weight:600; color:var(--muted)}
    .menu{display:flex; gap:18px; align-items:center}
    .menu a{color:var(--text); opacity:.9}
    .menu a:hover{opacity:1}
    .lang{display:inline-flex; gap:6px; align-items:center; padding:4px;
      border:1px solid var(--border); border-radius:999px; background:#141722; color:#d8e0ee; font-size:.9rem}
    .lang button{appearance:none; border:none; background:transparent; color:inherit;
      padding:6px 12px; border-radius:999px; font-weight:600; font-size:.86rem; letter-spacing:.02em;
      transition: background .2s ease, color .2s ease, box-shadow .2s ease; cursor:pointer}
    .lang button[aria-pressed="true"]{background:linear-gradient(135deg, rgba(31,111,235,.92), rgba(43,212,161,.9));
      color:#061427; box-shadow:0 0 0 2px rgba(8,14,30,.6), 0 10px 20px rgba(8,18,38,.35)}
    .lang button[aria-pressed="false"]{color:rgba(225,233,247,.82)}
    .lang button:focus-visible{outline:2px solid rgba(62,142,255,.9); outline-offset:2px}
    .hamb{display:none; background:#151a27; border:1px solid var(--border); color:#e6ebf2; padding:8px 10px; border-radius:10px}
    @media (max-width:860px){
      .hamb{display:inline-flex}
      .menu{
        display:none; position: fixed; right:12px;
        top: calc(var(--header-h) + 6px);
        flex-direction:column; gap:10px;
        background:#0e1118; border:1px solid var(--border); border-radius:12px; padding:12px;
        width: calc(100vw - 24px)
      }
      .menu.open{display:flex}
      .menu .lang{align-self:stretch; justify-content:space-between}
    }

    /* HERO */
    .hero{
      position:relative; min-height:calc(100svh - var(--header-h));
      display:flex; align-items:flex-start;
      padding: calc(var(--header-h) + 24px) 0 10svh;
      isolation:isolate; overflow: clip;
    }
    .hero .container{ position:relative; z-index:3; max-width: var(--container); }
    .hero .stack{
      display:flex; flex-direction:column; gap:10px;
      margin-top: min(8vh, 80px);
      max-width: 860px;
    }

    /* Badge = true fit-content + nowrap */
    .badge{
      display:inline-flex;
      width:max-content;
      white-space:nowrap;
      align-self:flex-start;
      align-items:center; gap:8px; font-size:.83rem; color:#cfe0ff;
      background:rgba(31,111,235,.12); border:1px solid rgba(31,111,235,.35);
      padding:6px 10px; border-radius:999px
    }

    h1{font-size:clamp(2rem, 5vw, 3.2rem); line-height:1.1; margin:6px 0 4px}
    .lead{font-size:clamp(1.05rem, 2.2vw, 1.25rem); color:var(--muted); max-width:780px}
    .cta{margin-top:18px; display:flex; gap:12px; flex-wrap:wrap}
    .btn{display:inline-flex; align-items:center; gap:10px; padding:12px 16px; border-radius:12px; font-weight:700;
      background:linear-gradient(135deg, var(--accent), #3aa0ff); color:white; border:none; cursor:pointer;
      box-shadow:0 10px 30px var(--ring)}
    .btn.ghost{background:#151a27; color:#d8e0ee; border:1px solid var(--border); box-shadow:none}

    /* FIXED full-bleed background canvas + vignette + fade */
    .hero-bg{ position:fixed; inset:0; z-index:1; pointer-events:none; }
    #viz3d{ display:block; width:100%; height:100%; }
    .hero-bg::after{
      content:""; position:absolute; inset:0; pointer-events:none;
      background:
        radial-gradient(1200px 700px at 70% -10%, rgba(43,212,161,.10), transparent 60%),
        radial-gradient(1000px 600px at -10% 0%, rgba(31,111,235,.14), transparent 60%),
        linear-gradient(to bottom, rgba(11,12,16,.25), rgba(11,12,16,.0) 35%, rgba(11,12,16,.0) 70%, rgba(11,12,16,.65));
      mix-blend-mode: screen;
    }
    .hero-fade{
      position:absolute; left:0; right:0; bottom:-1px; height:22svh; z-index:2; pointer-events:none;
      background: linear-gradient(to bottom, rgba(11,12,16,0), var(--bg));
    }

    /* Sections */
    main > section{scroll-margin-top: calc(var(--header-h) + 36px);}
    main > section:not(.hero){
      position:relative; min-height:auto;
      display:flex; align-items:center;
      padding: clamp(72px, 16vh, 140px) 0;
      background:
        radial-gradient(900px 420px at 12% 6%, rgba(31,111,235,.12), transparent 65%),
        radial-gradient(780px 360px at 88% 88%, rgba(43,212,161,.1), transparent 72%),
        linear-gradient(180deg, rgba(16,19,28,.96), rgba(10,12,18,.94) 58%, rgba(8,10,15,1));
      border-top:1px solid var(--border)
    }
    @media (max-width:760px){
      main > section:not(.hero){
        padding: clamp(56px, 14vh, 110px) 0;
        background:
          radial-gradient(720px 320px at 15% 5%, rgba(31,111,235,.16), transparent 62%),
          radial-gradient(620px 320px at 85% 92%, rgba(43,212,161,.14), transparent 70%),
          linear-gradient(180deg, rgba(13,16,24,.96), rgba(9,11,17,1));
      }
    }
    .section-inner{
      width:var(--container); margin:0 auto; padding:0 8px;
      display:grid; grid-template-columns: 1fr 1fr; gap:clamp(20px, 3vw, 28px);
      align-items:stretch;
    }
    @media (max-width:980px){ .section-inner{grid-template-columns:1fr} }
    h2{font-size:1.6rem; margin:0 0 12px}
    .section-inner h2{ position:relative; padding-top:6px; }
    .section-inner h2::before{
      content:""; position:absolute; left:0; top:0; height:4px; width:56px;
      border-radius:999px;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      opacity:.9;
    }
    .card{background: linear-gradient(155deg, rgba(22,28,40,.92), rgba(16,22,34,.9) 52%, rgba(19,24,37,.98));
      border:1px solid rgba(78,110,166,.22); border-radius:var(--radius); padding: var(--pad);
      box-shadow: 0 18px 42px rgba(3,6,15,.45);
      display:flex; flex-direction:column; gap:10px}
    .list{display:grid; gap:10px; margin:14px 0 0; padding:0; list-style:none}
    .list li{display:grid; grid-template-columns: 14px 1fr; align-items:start; column-gap:10px}
    .list li::before{content:""; width:10px; height:10px; margin-top:.4em; border-radius:999px; background:linear-gradient(135deg, var(--accent), var(--accent-2)); box-shadow:0 0 0 3px rgba(255,255,255,.03)}
    .mono{font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; font-size:.95rem; color:#b7c3d4}
    .muted{color:var(--muted)}

    form{margin-top:12px}
    form .row{display:grid; gap:12px; grid-template-columns:1fr 1fr}
    @media (max-width:700px){form .row{grid-template-columns:1fr}}
    input, textarea{width:100%; padding:14px 16px; border-radius:12px; border:1px solid var(--border); background:#0f1220; color: var(--text)}
    textarea{min-height:140px; resize:vertical}

    footer{background:#0a0c12; padding:42px 0; border-top:1px solid var(--border); color:#muted; font-size:.95rem}
    .cols{width:var(--container); margin:0 auto; padding:0 8px; display:grid; gap:20px; grid-template-columns: 1.3fr 1fr 1fr 1fr}
    @media (max-width:980px){ .cols{grid-template-columns:1fr 1fr} }
    @media (max-width:640px){ .cols{grid-template-columns:1fr} }
    .pill{display:inline-block; padding:6px 10px; border:1px solid var(--border); border-radius:999px; color:#d6deed}
    .footer-links a{display:block; margin:6px 0; color:#cfd6e6; opacity:.9}
    .footer-links a:hover{opacity:1; text-decoration:none}
    .sr-only{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0}

    @media (prefers-reduced-motion: reduce){
      .hero .container{transform:none !important}
      main > section:not(.hero){min-height:auto}
    }
    @media (max-height: 720px){
      main > section:not(.hero){ min-height:auto; }
    }
  </style>
</head>
<body>
<header>
  <div class="container nav">
    <div class="brand" aria-label="Noonautics Labs">
      <div class="logo" aria-hidden="true"></div>
      <div>
        NOONAUTICS LABS
        <small data-i18n="tagline">R&amp;D • Cell Sim • Bioinformatics</small>
      </div>
    </div>
    <button class="hamb" id="hamb" aria-expanded="false" aria-controls="menu" aria-label="Open main menu">Menu</button>
    <nav class="menu" id="menu" aria-label="Primary">
      <a href="#project" data-i18n="nav_project">Project</a>
      <a href="#technology" data-i18n="nav_tech">Technology</a>
      <a href="#company" data-i18n="nav_company">Company</a>
      <a href="#team" data-i18n="nav_team">Team</a>
      <a href="#contact" data-i18n="nav_contact">Contact</a>
      <span class="lang" role="group" aria-label="Language">
        <button type="button" id="lang-en" aria-pressed="true">EN</button>
        <button type="button" id="lang-pl" aria-pressed="false">PL</button>
      </span>
    </nav>
  </div>
</header>

<main>
  <!-- HERO -->
  <section class="hero" id="project" aria-label="SiCell hero">
    <div class="hero-bg" aria-hidden="true"><canvas id="viz3d"></canvas></div>
    <div class="hero-fade" aria-hidden="true"></div>
    <div class="container">
      <div class="stack">
        <span class="badge"><span class="sr-only">Project: </span><span data-i18n="hero_badge">SiCell — Flagship Project</span></span>
        <h1 data-i18n="hero_title">Full human cell simulations — closing the gap between silicon and carbon.</h1>
        <p class="lead" data-i18n="hero_lead">
          <strong>SiCell</strong> is our audacious step toward programmable biology:
          universal initial-state definitions, mechanistic models, and a search engine
          to explore disease mechanisms and pharma targets — as fast and iterative as software.
        </p>
        <div class="cta">
          <a class="btn" href="#contact" role="button" aria-label="Contact us" data-i18n="cta_contact">Contact us</a>
          <button class="btn ghost" type="button" disabled title="Whitepaper coming soon" data-i18n="cta_whitepaper">Whitepaper (soon)</button>
        </div>
      </div>
    </div>
  </section>

  <!-- TECHNOLOGY -->
  <section id="technology" aria-label="Technology">
    <div class="section-inner">
      <div class="card">
        <h2 data-i18n="tech_title">Technology</h2>
        <p class="muted" data-i18n="tech_intro">
          From curated databases to mechanistic graphs:
          we synthesize structured knowledge into deterministic systems that run fast and compose cleanly.
        </p>
        <ul class="list">
          <li><span data-i18n="tech_point1">Universal <strong>initial state</strong>: genes, epigenetics, organelles, protein levels → any cell type (neuron, stem, cancer, engineered).</span></li>
          <li><span data-i18n="tech_point2">Mechanistic <strong>ODE/graph models</strong> with feedback loops; no trillion-param training needed.</span></li>
          <li><span data-i18n="tech_point3"><strong>Search engine</strong> to explore disease pathways, targets, apoptosis routes, and drug effects.</span></li>
          <li><span data-i18n="tech_point4">Simple <strong>APIs &amp; visuals</strong> for rapid prototyping, like software.</span></li>
        </ul>
      </div>
      <div class="card">
        <h2 data-i18n="why_title">Why now?</h2>
        <p class="muted" data-i18n="why_text">
          It’s a paradox: we run trillion-parameter AIs trained from scratch, yet biology —
          where we already know so much — trails behind. We aim to close the gap between silicon on CPUs and carbon in cells, bringing biology into the era of emergent, iterative tooling.
        </p>
        <p class="mono" data-i18n="why_motto">“Make biology buildable.”</p>
      </div>
    </div>
  </section>

  <!-- COMPANY -->
  <section id="company" aria-label="Company">
    <div class="section-inner">
      <div class="card">
        <h2 data-i18n="about_title">About Noonautics Labs</h2>
        <p><strong>NOONAUTICS LABS SPÓŁKA Z OGRANICZONĄ ODPOWIEDZIALNOŚCIĄ</strong><br/>
          <span class="muted" data-i18n="about_legal">Legal form: sp. z o.o. • Kraków (Kraków-Podgórze), Małopolskie</span></p>
        <p class="muted" data-i18n="about_desc">BADANIA I ROZWÓJ W ZAKRESIE SYMULACJI KOMÓRKOWYCH, BIOINFORMATYKI I TWORZENIA NARZĘDZI DLA BIOTECHNOLOGII.</p>
      </div>
      <div class="card">
        <h2 data-i18n="focus_title">Focus</h2>
        <ul class="list">
          <li><span data-i18n="focus_1">Full human cell simulations (mechanistic).</span></li>
          <li><span data-i18n="focus_2">Bioinformatics pipelines &amp; knowledge synthesis.</span></li>
          <li><span data-i18n="focus_3">Developer-grade tools for biotech teams.</span></li>
        </ul>
      </div>
    </div>
  </section>

  <!-- TEAM -->
  <section id="team" aria-label="Team">
    <div class="section-inner">
      <div class="card">
        <h2 data-i18n="team_title">Team</h2>
        <p><strong>Marcel Tomaszek</strong> — <span data-i18n="team_affil">Cellular &amp; Molecular Biophysics, UJ</span></p>
        <p><a href="mailto:marcel.tomaszek@student.uj.edu.pl">marcel.tomaszek@student.uj.edu.pl</a></p>
      </div>
      <div class="card">
        <h2 data-i18n="next_title">What we’re building next</h2>
        <ul class="list">
          <li><span data-i18n="next_1">Open APIs for state definitions and simulation control.</span></li>
          <li><span data-i18n="next_2">Interactive visuals for pathway exploration.</span></li>
          <li><span data-i18n="next_3">Whitepaper &amp; demo (in progress).</span></li>
        </ul>
      </div>
    </div>
  </section>

  <!-- CONTACT -->
  <section id="contact" aria-label="Contact">
    <div class="section-inner">
      <div class="card">
        <h2 data-i18n="contact_title">Contact</h2>
        <p><span data-i18n="contact_general">General</span>:
          <a href="mailto:contact@noonauticslabs.org">contact@noonauticslabs.org</a></p>

        <form id="mailtoForm">
          <div class="row">
            <div>
              <label class="sr-only" for="name">Name</label>
              <input id="name" name="name" type="text" placeholder="Name / Company" required>
            </div>
            <div>
              <label class="sr-only" for="email">Email</label>
              <input id="email" name="email" type="email" placeholder="Email" required>
            </div>
          </div>
          <label class="sr-only" for="message">Message</label>
          <textarea id="message" name="message" placeholder="How can we collaborate?" required></textarea>
          <div class="cta" style="margin-top:14px">
            <button class="btn" type="submit" data-i18n="contact_send">Send</button>
            <a class="btn ghost" href="mailto:contact@noonauticslabs.org" data-i18n="contact_email">Email instead</a>
          </div>
          <p class="muted" style="margin-top:8px">No backend needed — this opens your email client with the details prefilled.</p>
        </form>

        <p class="muted" data-i18n="contact_note" style="margin-top:10px">We’re preparing our conference materials. A whitepaper and demo access will follow.</p>
      </div>

      <div class="card">
        <h2 data-i18n="partners_title">For partners</h2>
        <p class="muted" data-i18n="partners_text">
          Exploration of disease mechanisms, target discovery, and in-silico hypothesis testing.
          Let’s collaborate on focused, mechanistic problems.
        </p>
      </div>
    </div>
  </section>
</main>

<footer>
  <div class="cols">
    <div>
      <span class="pill">SiCell</span>
      <div style="margin-top:8px">© 2025 Noonautics Labs sp. z o.o. — Kraków, Poland</div>
    </div>
    <div class="footer-links">
      <div class="muted">Company</div>
      <a href="#company" data-i18n="nav_company">About</a>
      <a href="#team" data-i18n="nav_team">Team</a>
      <a href="#" aria-disabled="true">Careers (soon)</a>
    </div>
    <div class="footer-links">
      <div class="muted">Project</div>
      <a href="#project" data-i18n="nav_project">Overview</a>
      <a href="#technology" data-i18n="nav_tech">Technology</a>
      <a href="#" aria-disabled="true">Whitepaper (soon)</a>
    </div>
    <div class="footer-links">
      <div class="muted">Legal</div>
      <a href="#" aria-disabled="true">Privacy (soon)</a>
      <a href="#" aria-disabled="true">Imprint (soon)</a>
    </div>
  </div>
</footer>

<!-- Core UI scripts -->
<script>
  "use strict";
  const hamb = document.getElementById('hamb');
  const menu = document.getElementById('menu');
  const header = document.querySelector('header');

  if (hamb && menu) {
    hamb.addEventListener('click', () => {
      const open = menu.classList.toggle('open');
      hamb.setAttribute('aria-expanded', String(open));
      if (open) header.classList.remove('hide');
    });
    for (const link of menu.querySelectorAll('a[href^="#"]')){
      link.addEventListener('click', () => {
        menu.classList.remove('open');
        hamb.setAttribute('aria-expanded', 'false');
      });
    }
  }

  let lastY = window.scrollY, ticking = false;
  function onScrollHeader() {
    const y = window.scrollY, dy = y - lastY;
    if (y > 2) header.classList.add('scrolled'); else header.classList.remove('scrolled');
    const menuOpen = menu && menu.classList.contains('open');
    if (!menuOpen && y > 80 && dy > 10) header.classList.add('hide');
    else if (dy < -6) header.classList.remove('hide');
    lastY = y; ticking = false;
  }
  window.addEventListener('scroll', () => { if (!ticking) { requestAnimationFrame(onScrollHeader); ticking = true; } });

  function setHeaderOffset(){
    const h = header.getBoundingClientRect().height;
    document.documentElement.style.setProperty('--header-h', `${Math.round(h)}px`);
  }
  addEventListener('load', setHeaderOffset);
  addEventListener('resize', setHeaderOffset);

  // Mailto form
  const form = document.getElementById('mailtoForm');
  if (form) form.addEventListener('submit', (e) => {
    e.preventDefault();
    const name = encodeURIComponent(document.getElementById('name').value.trim());
    const email = encodeURIComponent(document.getElementById('email').value.trim());
    const msg = encodeURIComponent(document.getElementById('message').value.trim());
    const subject = encodeURIComponent('Noonautics Labs — Website Contact');
    const body = `Name/Company: ${name}%0AEmail: ${email}%0A%0A${msg}`;
    window.location.href = `mailto:contact@noonauticslabs.org?subject=${subject}&body=${body}`;
  });

  // i18n (concise)
  const dict = {
    en: {
      tagline:"R&D • Cell Sim • Bioinformatics",
      nav_project:"Project", nav_tech:"Technology", nav_company:"Company", nav_team:"Team", nav_contact:"Contact",
      hero_badge:"SiCell — Flagship Project",
      hero_title:"Full human cell simulations — closing the gap between silicon and carbon.",
      hero_lead:"<strong>SiCell</strong> is our audacious step toward programmable biology: universal initial-state definitions, mechanistic models, and a search engine to explore disease mechanisms and pharma targets — as fast and iterative as software.",
      cta_contact:"Contact us", cta_whitepaper:"Whitepaper (soon)",
      tech_title:"Technology",
      tech_intro:"From curated databases to mechanistic graphs: we synthesize structured knowledge into deterministic systems that run fast and compose cleanly.",
      tech_point1:"Universal <strong>initial state</strong>: genes, epigenetics, organelles, protein levels → any cell type (neuron, stem, cancer, engineered).",
      tech_point2:"Mechanistic <strong>ODE/graph models</strong> with feedback loops; no trillion-param training needed.",
      tech_point3:"<strong>Search engine</strong> to explore disease pathways, targets, apoptosis routes, and drug effects.",
      tech_point4:"Simple <strong>APIs & visuals</strong> for rapid prototyping, like software.",
      why_title:"Why now?", why_text:"It’s a paradox: we run trillion-parameter AIs trained from scratch, yet biology — where we already know so much — trails behind. We aim to close the gap between silicon on CPUs and carbon in cells, bringing biology into the era of emergent, iterative tooling.",
      why_motto:"“Make biology buildable.”",
      about_title:"About Noonautics Labs", about_legal:"Legal form: sp. z o.o. • Kraków (Kraków-Podgórze), Małopolskie",
      about_desc:"BADANIA I ROZWÓJ W ZAKRESIE SYMULACJI KOMÓRKOWYCH, BIOINFORMATYKI I TWORZENIA NARZĘDZI DLA BIOTECHNOLOGII.",
      focus_title:"Focus", focus_1:"Full human cell simulations (mechanistic).", focus_2:"Bioinformatics pipelines & knowledge synthesis.", focus_3:"Developer-grade tools for biotech teams.",
      team_title:"Team", team_affil:"Cellular & Molecular Biophysics, UJ",
      next_title:"What we’re building next", next_1:"Open APIs for state definitions and simulation control.", next_2:"Interactive visuals for pathway exploration.", next_3:"Whitepaper & demo (in progress).",
      contact_title:"Contact", contact_general:"General", contact_send:"Send", contact_email:"Email instead",
      contact_note:"We’re preparing our conference materials. A whitepaper and demo access will follow.",
      partners_title:"For partners", partners_text:"Exploration of disease mechanisms, target discovery, and in-silico hypothesis testing. Let’s collaborate on focused, mechanistic problems."
    },
    pl: {
      tagline:"B+R • Symulacje komórkowe • Bioinformatyka",
      nav_project:"Projekt", nav_tech:"Technologia", nav_company:"Spółka", nav_team:"Zespół", nav_contact:"Kontakt",
      hero_badge:"SiCell — projekt flagowy",
      hero_title:"Symulacje komórek w pełnej skali — zamykamy lukę między krzemem a węglem.",
      hero_lead:"<strong>SiCell</strong> to nasz odważny krok w stronę programowalnej biologii: definicje stanów początkowych, modele mechanistyczne i wyszukiwarka do analizy mechanizmów chorób oraz celów farmaceutycznych.",
      cta_contact:"Skontaktuj się", cta_whitepaper:"Biała księga (wkrótce)",
      tech_title:"Technologia", tech_intro:"Od kuratorowanych baz do modeli mechanistycznych — szybkie i komponowalne systemy.",
      tech_point1:"Elastyczne <strong>stany początkowe</strong> → dowolny typ komórki.",
      tech_point2:"<strong>Modele ODE/grafowe</strong> ze sprzężeniami zwrotnymi.",
      tech_point3:"<strong>Wyszukiwarka</strong> szlaków i efektów leków.",
      tech_point4:"Proste <strong>API i wizualizacje</strong>.",
      why_title:"Dlaczego teraz?", why_text:"Domykamy lukę między krzemem a komórką.",
      why_motto:"„Sprawmy, by biologia stała się inżynierią.”",
      about_title:"O Noonautics Labs", about_legal:"Forma prawna: sp. z o.o. • Kraków (Kraków-Podgórze)",
      about_desc:"Symulacje komórkowe, bioinformatyka, narzędzia dla biotech.",
      focus_title:"Zakres", focus_1:"Symulacje komórkowe.", focus_2:"Pipeline’y i synteza wiedzy.", focus_3:"Narzędzia deweloperskie.",
      team_title:"Zespół", team_affil:"Biofizyka komórkowa i molekularna, UJ",
      next_title:"Co dalej", next_1:"Otwarte API.", next_2:"Interaktywne wizualizacje.", next_3:"Biała księga i demo.",
      contact_title:"Kontakt", contact_general:"Ogólne", contact_send:"Wyślij", contact_email:"Wyślij e-mail",
      contact_note:"Przygotowujemy materiały konferencyjne.",
      partners_title:"Dla partnerów", partners_text:"Mechanizmy chorób, cele terapeutyczne, hipotezy in-silico."
    }
  };
  function setLang(lang){
    document.documentElement.setAttribute('lang', lang);
    document.documentElement.dataset.lang = lang;
    for (const el of document.querySelectorAll('[data-i18n]')) {
      const key = el.getAttribute('data-i18n'); const html = dict[lang][key] || '';
      if (html) el.innerHTML = html;
    }
    document.getElementById('lang-en').setAttribute('aria-pressed', lang==='en');
    document.getElementById('lang-pl').setAttribute('aria-pressed', lang==='pl');
    try { localStorage.setItem('lang', lang); } catch(e) {}
  }
  document.getElementById('lang-en').addEventListener('click', ()=>setLang('en'));
  document.getElementById('lang-pl').addEventListener('click', ()=>setLang('pl'));
  (function initLang(){
    let saved = null; try { saved = localStorage.getItem('lang'); } catch(e) {}
    if (!saved) { const ul = (navigator.language||'en').toLowerCase(); saved = ul.startsWith('pl') ? 'pl' : 'en'; }
    setLang(saved);
  })();
</script>

<!-- WebGL background: torus “tire dive”, scroll-scrub + fade edges -->
<script>
(() => {
  "use strict";
  const canvas = document.getElementById('viz3d');
  if (!canvas) return;
  const gl = canvas.getContext('webgl', {
    antialias:true, alpha:false, premultipliedAlpha:true, powerPreference:'high-performance'
  });
  if (!gl) return;

  const DPR = Math.min(2, window.devicePixelRatio || 1);
  function resize(){
    const w = Math.max(360, innerWidth);
    const h = Math.max(360, innerHeight);
    canvas.width = Math.round(w * DPR);
    canvas.height = Math.round(h * DPR);
    gl.viewport(0,0,canvas.width, canvas.height);
  }
  resize(); addEventListener('resize', resize);

  /* Matrices */
  const M = {
    perspective(fov, aspect, near, far){
      const f = 1/Math.tan(fov/2), nf = 1/(near-far);
      return new Float32Array([f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,(2*far*near)*nf,0]);
    },
    lookAt(eye,center,up){
      const [ex,ey,ez]=eye,[cx,cy,cz]=center,[ux,uy,uz]=up;
      let zx=ex-cx, zy=ey-cy, zz=ez-cz; let zl=Math.hypot(zx,zy,zz); zx/=zl; zy/=zl; zz/=zl;
      let xx = uy*zz - uz*zy, xy = uz*zx - ux*zz, xz = ux*zy - uy*zx;
      let xl=Math.hypot(xx,xy,xz); xx/=xl; xy/=xl; xz/=xl;
      const yx = zy*xz - zz*xy, yy = zz*xx - zx*xz, yz = zx*xy - zy*xx;
      return new Float32Array([xx,yx,zx,0, xy,yy,zy,0, xz,yz,zz,0, -(xx*ex+xy*ey+xz*ez), -(yx*ex+yy*ey+yz*ez), -(zx*ex+zy*ey+zz*ez), 1]);
    },
    rotateZ(a){
      const c=Math.cos(a), s=Math.sin(a);
      return new Float32Array([c,-s,0,0, s,c,0,0, 0,0,1,0, 0,0,0,1]);
    }
  };

  /* Shaders (alpha softened, bigger points) */
  const V_SRC = `
  attribute vec3 position;
  attribute vec3 color;
  attribute float pulse;
  attribute float alpha;
  uniform mat4 uProj, uView, uModel;
  varying vec3 vColor;
  varying float vDepth;
  varying float vPulse;
  varying float vAlpha;
  void main(){
    vec4 world = uModel * vec4(position, 1.0);
    vec4 view = uView * world;
    vDepth = -view.z;
    vColor = color;
    vPulse = pulse;
    vAlpha = alpha;
    gl_Position = uProj * view;
    gl_PointSize = 48.0 / (0.55 + vDepth*0.3); /* softer dots */
  }`;
  const F_POINTS = `
  precision mediump float;
  varying vec3 vColor;
  varying float vDepth;
  varying float vPulse;
  varying float vAlpha;
  void main(){
    vec2 p = gl_PointCoord*2.0 - 1.0;
    float r2 = dot(p,p);
    if (r2 > 1.0) discard;
    vec3 N = normalize(vec3(p.x, p.y, sqrt(max(0.0, 1.0 - r2))));
    vec3 L = normalize(vec3(0.6, 0.9, 1.0));
    float diff = 0.5 + 0.5*max(0.0, dot(N,L));
    float spec = pow(max(0.0, dot(reflect(-L,N), vec3(0.0,0.0,1.0))), 42.0) * 0.35;
    float halo = smoothstep(0.9, 0.0, r2) * vPulse * 0.9;
    float fog = clamp((vDepth-1.0) / 9.0, 0.0, 1.0);
    vec3 base = vColor*(diff + 0.12*halo) + spec*vec3(1.0);
    base = mix(base, vec3(0.03,0.05,0.09), fog);
    gl_FragColor = vec4(base, 0.86 * vAlpha);
  }`;
  const V_LINES = `
  attribute vec3 position;
  attribute vec3 color;
  attribute float pulse;
  attribute float alpha;
  uniform mat4 uProj, uView, uModel;
  varying vec3 vColor;
  varying float vDepth;
  varying float vPulse;
  varying float vAlpha;
  void main(){
    vec4 world = uModel * vec4(position, 1.0);
    vec4 view = uView * world;
    vDepth = -view.z; vColor = color; vPulse = pulse; vAlpha = alpha;
    gl_Position = uProj * view;
  }`;
  const F_LINES = `
  precision mediump float;
  varying vec3 vColor;
  varying float vDepth;
  varying float vPulse;
  varying float vAlpha;
  void main(){
    float fog = clamp((vDepth-1.0) / 9.0, 0.0, 1.0);
    vec3 col = mix(vColor + vPulse*vec3(0.35,0.55,0.9), vec3(0.03,0.05,0.09), fog);
    gl_FragColor = vec4(col, (0.35 + 0.35*min(1.0, vPulse)) * vAlpha);
  }`;

  function compile(src, type){ const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s)); return s; }
  function program(vs, fs){ const p=gl.createProgram();
    gl.attachShader(p, compile(vs, gl.VERTEX_SHADER));
    gl.attachShader(p, compile(fs, gl.FRAGMENT_SHADER));
    gl.linkProgram(p); if(!gl.getProgramParameter(p, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(p));
    return p;
  }
  const PROG_POINTS = program(V_SRC, F_POINTS);
  const PROG_LINES  = program(V_LINES, F_LINES);

  const uPoints = {
    uProj: gl.getUniformLocation(PROG_POINTS,'uProj'),
    uView: gl.getUniformLocation(PROG_POINTS,'uView'),
    uModel: gl.getUniformLocation(PROG_POINTS,'uModel')
  };
  const uLines = {
    uProj: gl.getUniformLocation(PROG_LINES,'uProj'),
    uView: gl.getUniformLocation(PROG_LINES,'uView'),
    uModel: gl.getUniformLocation(PROG_LINES,'uModel')
  };

  function attrib(p, name, buf, size){
    const loc = gl.getAttribLocation(p, name);
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(loc, size, gl.FLOAT, false, 0, 0);
  }

  /* --- Torus “air in tire” graph with soft surface constraint --- */
  const N = 110;
  const MAX_EDGES = 260;
  const positions = new Float32Array(N*3);
  const velocities = new Float32Array(N*3);
  const colors = new Float32Array(N*3);
  const pulsesAttrib = new Float32Array(N);
  const tmpF = new Float32Array(N*3);

  const R = 1.7, r = 0.55;                      // torus major/minor radii
  const TORUS_K = 1.4;                           // surface pull strength
  const PULL=0.01, DAMP=0.92, REPULSE=0.018, SPRING_K=0.11, BREAK_STRETCH=1.9;

  function torusPoint(a,b){
    const x = (R + r*Math.cos(b))*Math.cos(a);
    const y = (R + r*Math.cos(b))*Math.sin(a);
    const z = r*Math.sin(b);
    return [x,y,z];
  }
  function nearestOnTorus(x,y,z){
    const a = Math.atan2(y, x);
    const radial = Math.hypot(x,y) - R;
    const b = Math.atan2(z, radial);
    const tx = (R + r*Math.cos(b))*Math.cos(a);
    const ty = (R + r*Math.cos(b))*Math.sin(a);
    const tz = r*Math.sin(b);
    return [tx,ty,tz];
  }

  for (let i=0;i<N;i++){
    const a = Math.random()*Math.PI*2;
    const b = Math.random()*Math.PI*2;
    const p = torusPoint(a,b);
    positions[i*3+0]=p[0]; positions[i*3+1]=p[1]; positions[i*3+2]=p[2];
    velocities[i*3+0]=(Math.random()-0.5)*0.003;
    velocities[i*3+1]=(Math.random()-0.5)*0.003;
    velocities[i*3+2]=(Math.random()-0.5)*0.003;
    colors.set([0.16,0.78,0.72], i*3);
  }

  /* Edges with fade in/out for smooth breaking */
  const edges = new Uint16Array(MAX_EDGES*2);
  const springRest = new Float32Array(MAX_EDGES);
  const edgeColor = new Float32Array(MAX_EDGES*2*3);
  const edgePulse = new Float32Array(MAX_EDGES*2);
  const edgeAlpha = new Float32Array(MAX_EDGES*2);   // per-vertex alpha (fade)
  const edgeLife  = new Float32Array(MAX_EDGES);     // 1 = alive target, 0 = removed target
  const edgeFade  = new Float32Array(MAX_EDGES);     // current fade 0..1
  let edgeCount = 0;

  function addEdge(a,b, startFade=0){
    if (a===b || edgeCount>=MAX_EDGES) return false;
    for(let e=0;e<edgeCount;e++){
      if ((edges[e*2]===a && edges[e*2+1]===b) || (edges[e*2]===b && edges[e*2+1]===a)) return false;
    }
    edges[edgeCount*2]=a; edges[edgeCount*2+1]=b;
    const dx=positions[a*3]-positions[b*3], dy=positions[a*3+1]-positions[b*3+1], dz=positions[a*3+2]-positions[b*3+2];
    springRest[edgeCount] = Math.max(0.42, Math.min(0.92, Math.hypot(dx,dy,dz)));
    const c1 = [0.12,0.62,0.98], c2 = Math.random()<0.12 ? [0.92,0.18,0.56] : [0.17,0.85,0.66];
    edgeColor.set(c1, edgeCount*6+0); edgeColor.set(c2, edgeCount*6+3);
    edgePulse[edgeCount*2] = 0.0; edgePulse[edgeCount*2+1] = 0.0;
    edgeLife[edgeCount] = 1.0;
    edgeFade[edgeCount] = startFade; // start small, fade in
    edgeCount++;
    return true;
  }

  function degree(){
    const d=new Uint16Array(N);
    for(let e=0;e<edgeCount;e++){ d[edges[e*2]]++; d[edges[e*2+1]]++; }
    return d;
  }
  for (let i=0;i<N;i++){
    for (let j=i+1;j<N;j++){
      if (edgeCount>=MAX_EDGES) break;
      const dx=positions[i*3]-positions[j*3], dy=positions[i*3+1]-positions[j*3+1], dz=positions[i*3+2]-positions[j*3+2];
      const d2=dx*dx+dy*dy+dz*dz;
      if (d2 < 1.6) addEdge(i,j, Math.random()*0.5);
    }
    if (edgeCount>=MAX_EDGES) break;
  }
  while (edgeCount < MAX_EDGES){
    const i=(Math.random()*N)|0, j=(Math.random()*N)|0;
    if (i!==j){
      const dx=positions[i*3]-positions[j*3], dy=positions[i*3+1]-positions[j*3+1], dz=positions[i*3+2]-positions[j*3+2];
      const d2=dx*dx+dy*dy+dz*dz;
      if (d2<2.5) addEdge(i,j, Math.random()*0.4);
    }
  }

  function makeBuf(type, data, usage){ const b=gl.createBuffer(); gl.bindBuffer(type,b); gl.bufferData(type,data,usage||gl.DYNAMIC_DRAW); return b; }
  const posBuf   = makeBuf(gl.ARRAY_BUFFER, positions);
  const colBuf   = makeBuf(gl.ARRAY_BUFFER, colors);
  const pulseBuf = makeBuf(gl.ARRAY_BUFFER, pulsesAttrib);
  const linePosBuf   = makeBuf(gl.ARRAY_BUFFER, new Float32Array(MAX_EDGES*2*3));
  const lineColBuf   = makeBuf(gl.ARRAY_BUFFER, edgeColor);
  const linePulseBuf = makeBuf(gl.ARRAY_BUFFER, edgePulse);
  const lineAlphaBuf = makeBuf(gl.ARRAY_BUFFER, edgeAlpha);

  const lineVerts = new Float32Array(MAX_EDGES*2*3);
  function updateLineVerts(){
    for (let e=0;e<edgeCount;e++){
      const a = edges[e*2], b = edges[e*2+1];
      lineVerts.set(positions.subarray(a*3,a*3+3), e*6+0);
      lineVerts.set(positions.subarray(b*3,b*3+3), e*6+3);
      const fade = edgeFade[e];
      edgePulse[e*2]   = nodePulse[a];
      edgePulse[e*2+1] = nodePulse[b];
      edgeAlpha[e*2]   = fade;
      edgeAlpha[e*2+1] = fade;
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, linePosBuf);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, lineVerts.subarray(0, edgeCount*6));
    gl.bindBuffer(gl.ARRAY_BUFFER, linePulseBuf);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, edgePulse.subarray(0, edgeCount*2));
    gl.bindBuffer(gl.ARRAY_BUFFER, lineAlphaBuf);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, edgeAlpha.subarray(0, edgeCount*2));
  }

  /* Physics + pulses */
  let timeScale = 0.06, timeScaleTarget = 0.06;
  const pulses = []; // {i, t0}
  const nodePulse = new Float32Array(N);
  const PULSE_SPEED = 0.32; const PULSE_FADE = 1.8;

  let lastPulse = performance.now();
  let pulseInterval = 3600, pulseIntervalTarget = 3600;

  function spawnPulse(){
    const deg = degree();
    let best = 0, bestScore = -1;
    for (let k=0;k<12;k++){
      const i = (Math.random()*N)|0;
      const score = (6 - Math.min(6, deg[i])) + Math.random()*0.5;
      if (score>bestScore){ bestScore=score; best=i; }
    }
    pulses.push({i:best, t0:performance.now()});
    if (pulses.length>3) pulses.shift();
  }

  function updatePulses(now){
    nodePulse.fill(0);
    for (const p of pulses){
      const age = (now - p.t0)/1000;
      const rad = age * PULSE_SPEED;
      if (age>6) continue;
      const sx=positions[p.i*3], sy=positions[p.i*3+1], sz=positions[p.i*3+2];
      for (let i=0;i<N;i++){
        const dx=positions[i*3]-sx, dy=positions[i*3+1]-sy, dz=positions[i*3+2]-sz;
        const d = Math.hypot(dx,dy,dz);
        const band = Math.exp(-((d-rad)*(d-rad))/(2*PULSE_FADE*PULSE_FADE));
        nodePulse[i] = Math.max(nodePulse[i], band);
      }
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, pulseBuf);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, nodePulse);
  }

  let lastRewire = performance.now();
  let rewireInterval = 6200, rewireIntervalTarget = 6200;

  function rewire(){
    const now = performance.now();
    if (now - lastRewire < rewireInterval) return;
    lastRewire = now;

    const toChange = Math.max(1, Math.floor(MAX_EDGES * 0.04));
    const willBreak = [];

    for (let e=0;e<edgeCount;e++){
      const a=edges[e*2], b=edges[e*2+1];
      const dx=positions[a*3]-positions[b*3], dy=positions[a*3+1]-positions[b*3+1], dz=positions[a*3+2]-positions[b*3+2];
      const d = Math.hypot(dx,dy,dz);
      if (d > springRest[e]*BREAK_STRETCH) willBreak.push(e);
      if (willBreak.length>=toChange) break;
    }
    while (willBreak.length<toChange){
      const e = (Math.random()*edgeCount)|0;
      if (!willBreak.includes(e)) willBreak.push(e);
    }

    /* mark for fade-out instead of instant removal */
    for (const e of willBreak){ edgeLife[e] = 0.0; }
  }

  function fadeEdges(dt){
    /* fade current edges toward their target state */
    for (let e=0;e<edgeCount;e++){
      const target = edgeLife[e];
      const cur = edgeFade[e];
      const rate = target>cur ? 1.5 : 1.2; // fade-in a bit faster than fade-out
      const next = cur + (target - cur) * Math.min(1, rate*dt);
      edgeFade[e] = Math.max(0, Math.min(1, next));
    }
    /* physically remove edges whose fade reached ~0, and add new ones fading in */
    for (let idx=edgeCount-1; idx>=0; idx--){
      if (edgeLife[idx]===0 && edgeFade[idx] < 0.03){
        // remove by swapping last
        edgeCount--;
        edges[idx*2]=edges[edgeCount*2]; edges[idx*2+1]=edges[edgeCount*2+1];
        springRest[idx]=springRest[edgeCount];
        edgeFade[idx]=edgeFade[edgeCount];
        edgeLife[idx]=edgeLife[edgeCount];
        for(let k=0;k<6;k++) edgeColor[idx*6+k]=edgeColor[edgeCount*6+k];
      }
    }
    // add back up to MAX_EDGES with fade-in
    const deg = degree();
    while (edgeCount < MAX_EDGES){
      const i=(Math.random()*N)|0, j=(Math.random()*N)|0;
      if (i===j) continue;
      const wI = 1/(1+deg[i]); const wJ = 1/(1+deg[j]);
      if (Math.random() > (0.65*wI + 0.65*wJ)) continue;
      const dx=positions[i*3]-positions[j*3], dy=positions[i*3+1]-positions[j*3+1], dz=positions[i*3+2]-positions[j*3+2];
      const d2=dx*dx+dy*dy+dz*dz;
      if (d2>0.35 && d2<2.4){
        addEdge(i,j, 0.05); // start faded, will fade in
      }
      if (Math.random()<0.3) break; // spread additions over frames
    }
  }

  function step(dt){
    tmpF.fill(0);
    // pairwise repulsion
    for (let i=0;i<N;i++){
      const ix=i*3, x=positions[ix], y=positions[ix+1], z=positions[ix+2];
      for (let j=i+1;j<N;j++){
        const jx=j*3;
        let dx = x - positions[jx], dy = y - positions[jx+1], dz = z - positions[jx+2];
        let d2 = dx*dx+dy*dy+dz*dz + 0.001;
        let inv = 1.0/Math.sqrt(d2);
        let f = REPULSE * inv*inv;
        dx*=f; dy*=f; dz*=f;
        tmpF[ix]+=dx; tmpF[ix+1]+=dy; tmpF[ix+2]+=dz;
        tmpF[jx]-=dx; tmpF[jx+1]-=dy; tmpF[jx+2]-=dz;
      }
    }
    // springs
    for (let e=0;e<edgeCount;e++){
      const a=edges[e*2], b=edges[e*2+1], ax=a*3, bx=b*3;
      let dx = positions[bx]-positions[ax];
      let dy = positions[bx+1]-positions[ax+1];
      let dz = positions[bx+2]-positions[ax+2];
      let d = Math.hypot(dx,dy,dz)+1e-6;
      const k = SPRING_K*(d - springRest[e]);
      const fx=(dx/d)*k, fy=(dy/d)*k, fz=(dz/d)*k;
      tmpF[ax]+=fx; tmpF[ax+1]+=fy; tmpF[ax+2]+=fz;
      tmpF[bx]-=fx; tmpF[bx+1]-=fy; tmpF[bx+2]-=fz;
    }
    // torus surface constraint (soft)
    for (let i=0;i<N;i++){
      const ix=i*3;
      const x=positions[ix], y=positions[ix+1], z=positions[ix+2];
      const t = nearestOnTorus(x,y,z);
      const dx=t[0]-x, dy=t[1]-y, dz=t[2]-z;
      tmpF[ix]   += dx*TORUS_K;
      tmpF[ix+1] += dy*TORUS_K;
      tmpF[ix+2] += dz*TORUS_K;
    }
    // integrate + center pull + colors
    for (let i=0;i<N;i++){
      const ix=i*3;
      velocities[ix]   = (velocities[ix]   + tmpF[ix]*dt) * DAMP;
      velocities[ix+1] = (velocities[ix+1] + tmpF[ix+1]*dt) * DAMP;
      velocities[ix+2] = (velocities[ix+2] + tmpF[ix+2]*dt) * DAMP;
      positions[ix]   += velocities[ix]*dt;
      positions[ix+1] += velocities[ix+1]*dt;
      positions[ix+2] += velocities[ix+2]*dt;

      positions[ix]   -= positions[ix]*PULL*dt*0.8;
      positions[ix+1] -= positions[ix+1]*PULL*dt*0.8;
      positions[ix+2] -= positions[ix+2]*PULL*dt*0.8;

      const sp = Math.min(1.0, Math.hypot(velocities[ix],velocities[ix+1],velocities[ix+2])*8.5);
      const cool=[0.16,0.78,0.72], warm=[0.92,0.18,0.56];
      colors[ix]   = cool[0]*(1-sp) + warm[0]*sp*0.55;
      colors[ix+1] = cool[1]*(1-sp) + warm[1]*sp*0.55;
      colors[ix+2] = cool[2]*(1-sp) + warm[2]*sp*0.55;
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, posBuf); gl.bufferSubData(gl.ARRAY_BUFFER, 0, positions);
    gl.bindBuffer(gl.ARRAY_BUFFER, colBuf); gl.bufferSubData(gl.ARRAY_BUFFER, 0, colors);
  }

  /* Scroll-scrubbed motion (video-like), with smoothed targets to avoid flicker */
  let scrollProg=0, scrollTarget=0;
  function onScroll(){
    const vh = Math.max(1, window.innerHeight);
    const y = window.scrollY;
    scrollTarget = Math.max(0, Math.min(0.95, y / (vh*1.6)));
    // target dynamics linked to scroll
    const ease = scrollTarget*scrollTarget*(3 - 2*scrollTarget);
    timeScaleTarget = 0.045 + 0.12*ease;
    rewireIntervalTarget = 6200 - 1800*ease;
    pulseIntervalTarget  = 3600 - 900*ease;
  }
  addEventListener('scroll', () => requestAnimationFrame(onScroll), {passive:true}); onScroll();

  /* Camera: inside torus, spin + forward; phase is scroll-scrubbed + gentle autoplay */
  let autoPhase = 0.0;
  function getCamera(dt){
    autoPhase += dt * 0.35; // gentle autoplay
    // blend scroll (dominant) with autoplay
    const phase = scrollProg*Math.PI*2.1 + autoPhase;
    const A = phase, B = phase*1.35 + 1.2; // twist in tube
    const cx = R*Math.cos(A), cy = R*Math.sin(A), cz = 0;
    const tx = -Math.sin(A), ty = Math.cos(A), tz = 0;
    const ex = cx + 0.16*Math.cos(B);
    const ey = cy + 0.16*Math.sin(B);
    const ez = 0 - 0.42;
    const center = [ex + tx*1.05, ey + ty*1.05, ez + tz*0.9];
    return {eye:[ex,ey,ez], center, spin: phase*0.25};
  }

  /* Points need an alpha of 1 (constant), edges get per-vertex alpha */
  const pointAlpha = new Float32Array(N).fill(1.0);
  const pointAlphaBuf = makeBuf(gl.ARRAY_BUFFER, pointAlpha);

  const uPointsLoc = { uProj: uPoints.uProj, uView: uPoints.uView, uModel: uPoints.uModel };
  const uLinesLoc  = { uProj: uLines.uProj,  uView: uLines.uView,  uModel: uLines.uModel };

  let lastTS = performance.now();
  function frame(ts){
    const rawDt = Math.min(40, ts - lastTS); lastTS = ts;
    const dt = (rawDt/1000);

    // smooth scroll & targets to avoid flicker
    scrollProg += (scrollTarget - scrollProg) * Math.min(1, 2.4*dt);
    timeScale += (timeScaleTarget - timeScale) * Math.min(1, 2.1*dt);
    rewireInterval += (rewireIntervalTarget - rewireInterval) * Math.min(1, 1.6*dt);
    pulseInterval += (pulseIntervalTarget - pulseInterval) * Math.min(1, 1.6*dt);

    const simDt = Math.min(0.0065, dt * timeScale);

    const now = performance.now();
    if (now - lastPulse > pulseInterval){ lastPulse = now; spawnPulse(); }
    updatePulses(now);

    step(simDt);
    rewire();
    fadeEdges(dt);
    updateLineVerts();

    const aspect = canvas.width/canvas.height;
    const proj = M.perspective(50*Math.PI/180, aspect, 0.1, 100.0);
    const cam = getCamera(dt);
    const view = M.lookAt(cam.eye, cam.center, [0,1,0]);
    const model = M.rotateZ(cam.spin); // the “tire” spins around us for an immersive feel

    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.clearColor(0.015,0.02,0.05,1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // LINES
    gl.useProgram(PROG_LINES);
    gl.uniformMatrix4fv(uLinesLoc.uProj,false,proj);
    gl.uniformMatrix4fv(uLinesLoc.uView,false,view);
    gl.uniformMatrix4fv(uLinesLoc.uModel,false,model);
    attrib(PROG_LINES,'position', linePosBuf, 3);
    attrib(PROG_LINES,'color',    lineColBuf, 3);
    attrib(PROG_LINES,'pulse',    linePulseBuf, 1);
    attrib(PROG_LINES,'alpha',    lineAlphaBuf, 1);
    gl.drawArrays(gl.LINES, 0, edgeCount*2);

    // POINTS
    gl.useProgram(PROG_POINTS);
    gl.uniformMatrix4fv(uPointsLoc.uProj,false,proj);
    gl.uniformMatrix4fv(uPointsLoc.uView,false,view);
    gl.uniformMatrix4fv(uPointsLoc.uModel,false,model);
    attrib(PROG_POINTS,'position', posBuf, 3);
    attrib(PROG_POINTS,'color',    colBuf, 3);
    attrib(PROG_POINTS,'pulse',    pulseBuf, 1);
    attrib(PROG_POINTS,'alpha',    pointAlphaBuf, 1);
    gl.drawArrays(gl.POINTS, 0, N);

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches){
    timeScale = 0.0; timeScaleTarget = 0.0;
    rewireInterval = rewireIntervalTarget = 1e9;
    pulseInterval = pulseIntervalTarget = 1e9;
  }
})();
</script>
</body>
</html>
